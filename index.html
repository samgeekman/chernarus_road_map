<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chernarus Roads Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; background: #2b2b2b; }
    #panel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #0008;
      color: #fff;
      padding: 8px 10px;
      font-family: sans-serif;
      border-radius: 4px;
      z-index: 1000;
      width: 240px;
    }
    #panel input { width: 100%; margin-top: 5px; box-sizing: border-box; }
    button { margin-top: 5px; width: 100%; }
    #savedList {
      margin-top: 8px;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    .marker-label {
      color: #fff; background: #0008; padding: 2px 6px;
      border-radius: 3px; font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <div><strong>Define Road:</strong></div>
    <div id="status">Click two intersections (A→B)</div>
    <input id="roadName" type="text" placeholder="Enter name..." />
    <button id="saveBtn">Save</button>
    <button id="downloadBtn">Download JSON</button>
    <div id="savedList"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ====== CONFIG ======
  const GITHUB_TOKEN = "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";     
  const REPO = "samgeekman/chernarus_road_map";       
  const BRANCH = "main";
  // ====================

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: -3,
    maxZoom: 6,
    center: [0, 0],
    zoom: 0
  });

  function key(x,y){return `${x.toFixed(3)},${y.toFixed(3)}`;}

  // --- GitHub fetch/save helpers ---
  async function fetchFromGitHub() {
    const url = `https://api.github.com/repos/${REPO}/contents/${FILE_PATH}?ref=${BRANCH}`;
    const res = await fetch(url);
    const data = await res.json();
    if (!data.content) return [];
    const decoded = decodeURIComponent(escape(atob(data.content)));
    return JSON.parse(decoded);
  }

  async function saveToGitHub(updatedData) {
    const apiURL = `https://api.github.com/repos/${REPO}/contents/${FILE_PATH}`;
    const getResp = await fetch(apiURL, {
      headers: { Authorization: `token ${GITHUB_TOKEN}` }
    });
    const meta = await getResp.json();

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(updatedData, null, 2))));
    const payload = {
      message: "Update roadnames.json",
      content,
      sha: meta.sha,
      branch: BRANCH
    };

    const putResp = await fetch(apiURL, {
      method: "PUT",
      headers: {
        Authorization: `token ${GITHUB_TOKEN}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    });

    if (putResp.ok) {
      console.log("✅ Saved to GitHub");
    } else {
      console.error("❌ GitHub save failed", await putResp.text());
    }
  }

  // --- Main map logic ---
  fetch("roads.geojson")
    .then(r=>r.json())
    .then(async data=>{
      const clone=structuredClone(data);
      const nodeMap={};
      clone.features.forEach((f,i)=>{
        const c=f.geometry.coordinates;
        const s=c[0], e=c[c.length-1];
        [s,e].forEach(([x,y])=>{
          const k=key(x,y);
          (nodeMap[k]??=[]).push(i);
        });
      });

      const roadsLayer=L.geoJSON(clone,{style:{color:"#ff5555",weight:8,opacity:0.25}}).addTo(map);
      map.fitBounds(roadsLayer.getBounds());

      let pointA=null, pointB=null, markers=[], currentSegs=null;
      let highlight=null;
      const savedLayer=L.layerGroup().addTo(map);

      // Load persistent roads
      let saved = await fetchFromGitHub().catch(()=>[]);
      const listDiv=document.getElementById("savedList");
      const status=document.getElementById("status");
      const nameBox=document.getElementById("roadName");

      function refreshList(){
        listDiv.innerHTML=saved.map(r=>`<div>${r.name}</div>`).join("");
      }
      refreshList();

      function drawSavedRoads(){
        savedLayer.clearLayers();
        saved.forEach(r=>{
          const feats=r.segs.map(i=>clone.features[i]);
          L.geoJSON(feats,{style:{color:"limegreen",weight:3,opacity:0.9}}).addTo(savedLayer);
        });
      }
      drawSavedRoads();

      // --- Pathfinding (bounded) ---
      function findPathSafe(startKey,endKey,maxSteps=5000){
        const queue=[startKey],visited=new Set([startKey]),parent={};
        let steps=0;
        while(queue.length && steps<maxSteps){
          const cur=queue.shift();steps++;
          if(cur===endKey)break;
          for(const idx of (nodeMap[cur]||[])){
            const f=clone.features[idx],c=f.geometry.coordinates,ends=[c[0],c[c.length-1]];
            for(const [x,y] of ends){
              const k=key(x,y);
              if(!visited.has(k)){visited.add(k);parent[k]=cur;queue.push(k);}
            }
          }
        }
        if(steps>=maxSteps){
          console.warn("Path search exceeded limit, aborting to prevent freeze.");
          return [];
        }
        const path=[];let k=endKey;
        while(k){path.unshift(k);k=parent[k];}
        if(path[0]!==startKey)return[];
        const segs=[];
        for(let i=0;i<path.length-1;i++){
          const a=path[i],b=path[i+1];
          const sa=nodeMap[a]||[],sb=nodeMap[b]||[];
          segs.push(...sa.filter(x=>sb.includes(x)));
        }
        return [...new Set(segs)];
      }

      function markPoint(latlng,label){
        const m=L.marker(latlng,{icon:L.divIcon({className:"marker-label",html:label})}).addTo(map);
        markers.push(m);
      }

      map.on("click",e=>{
        const clicked=map.layerPointToLatLng(e.layerPoint);
        const [x,y]=[clicked.lng,clicked.lat];
        const nearest=Object.keys(nodeMap)
          .map(k=>{const[nx,ny]=k.split(',').map(Number);
                   return{k,d:Math.hypot(nx-x,ny-y)};})
          .sort((a,b)=>a.d-b.d)[0];
        if(!nearest)return;

        if(!pointA){
          pointA=nearest.k;markPoint(e.latlng,"A");
          status.innerText="Select point B";
        }else{
          pointB=nearest.k;markPoint(e.latlng,"B");
          setTimeout(()=>{
            const segs=findPathSafe(pointA,pointB);
            if(segs.length){
              const feats=segs.map(i=>clone.features[i]);
              if(highlight)map.removeLayer(highlight);
              highlight=L.geoJSON(feats,{style:{color:"yellow",weight:4}}).addTo(map);
              status.innerText="Enter name then Save";
              currentSegs=segs;
            }else{
              status.innerText="No connection found or search limited.";
              currentSegs=null;
            }
            pointA=null;pointB=null;
            markers.forEach(m=>map.removeLayer(m));markers=[];
          },10);
        }
      });

      // --- Save button ---
      document.getElementById("saveBtn").onclick=async()=>{
        const name=nameBox.value.trim();
        if(!name||!currentSegs){status.innerText="Select A→B and enter name.";return;}
        const entry={name,segs:currentSegs};
        saved.push(entry);
        refreshList();
        drawSavedRoads();
        nameBox.value="";
        currentSegs=null;
        status.innerText="Saving to GitHub...";
        if(highlight){map.removeLayer(highlight);highlight=null;}

        try {
          await saveToGitHub(saved);
          status.innerText="✅ Saved to GitHub! Click new A→B";
        } catch (err) {
          console.error(err);
          status.innerText="❌ Failed to save to GitHub (check console)";
        }
      };

      // --- Download JSON ---
      document.getElementById("downloadBtn").onclick=()=>{
        const blob=new Blob([JSON.stringify(saved,null,2)],{type:"application/json"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url;a.download="roadnames.json";a.click();
        URL.revokeObjectURL(url);
      };
    })
    .catch(err=>console.error(err));
  </script>
</body>
</html>