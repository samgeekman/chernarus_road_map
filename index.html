<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chernarus Roads Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; background: #2b2b2b; }
    #panel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #0008;
      color: #fff;
      padding: 8px 10px;
      font-family: sans-serif;
      border-radius: 4px;
      z-index: 1000;
      width: 230px;
    }
    #panel input { width: 100%; margin-top: 5px; box-sizing: border-box; }
    button { margin-top: 5px; width: 100%; cursor: pointer; }
    #savedList {
      margin-top: 8px;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    .marker-label {
      color: #fff;
      background: #0008;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
    }
    .list-item {
      cursor: pointer;
      padding: 2px 0;
    }
    .list-item:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <div><strong>Define Road:</strong></div>
    <div id="status">Click two road lines (A→B)</div>
    <input id="roadName" type="text" placeholder="Enter name..." />
    <button id="saveBtn">Save</button>
    <button id="clearBtn">Clear Selection</button>
    <button id="downloadBtn">Download JSON</button>
    <button id="importBtn">Import JSON</button>
    <div id="savedList"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: -3,
    maxZoom: 6,
    center: [0, 0],
    zoom: 0
  });

  // --- Base image overlay ---
  const imageUrl = "chernarus_map.jpeg";
  const imageBounds = [[-242.500, 221.871], [295.500, 819.700]];
  L.imageOverlay(imageUrl, imageBounds).addTo(map);
  map.fitBounds(imageBounds);

  function key(x,y){return `${x.toFixed(3)},${y.toFixed(3)}`;}

  fetch("roads.geojson")
    .then(r=>r.json())
    .then(data=>{
      const clone = structuredClone(data);
      const nodeMap = {};

      // Map all intersections
      clone.features.forEach((f,i)=>{
        const c=f.geometry.coordinates;
        const s=c[0], e=c[c.length-1];
        [s,e].forEach(([x,y])=>{
          const k=key(x,y);
          (nodeMap[k]??=[]).push(i);
        });
      });

      // --- Main red roads layer ---
      const roadsLayer = L.geoJSON(clone,{
        style:{color:"#ff5555",weight:8,opacity:0.50}
      }).addTo(map);

      let pointA=null, pointB=null, highlight=null, markers=[], currentSegs=null;
      const saved=JSON.parse(localStorage.getItem("roadNames")||"[]");

      const savedLayer=L.layerGroup().addTo(map);
      const listDiv=document.getElementById("savedList");
      const status=document.getElementById("status");
      const nameBox=document.getElementById("roadName");
      const roadRefs={};

      function refreshList(){
        listDiv.innerHTML = saved.map((r,i)=>`<div class="list-item" data-index="${i}">${r.name}</div>`).join("");
        document.querySelectorAll(".list-item").forEach(el=>{
          el.onclick = () => {
            const i = parseInt(el.dataset.index);
            const ref = roadRefs[i];
            if(ref){
              map.fitBounds(ref.layer.getBounds(), {maxZoom: 3});
              ref.tooltip.openOn(map);
            }
          };
        });
      }

      function drawSavedRoads(){
        savedLayer.clearLayers();
        Object.keys(roadRefs).forEach(k => delete roadRefs[k]);
        saved.forEach((r, i)=>{
          const feats=r.segs.map(si=>clone.features[si]);
          const layer=L.geoJSON(feats,{style:{color:"limegreen",weight:3,opacity:0.9}}).addTo(savedLayer);
          const coords = feats.flatMap(f=>f.geometry.coordinates);
          const avgX = coords.reduce((a,c)=>a+c[0],0)/coords.length;
          const avgY = coords.reduce((a,c)=>a+c[1],0)/coords.length;
          const tooltip = L.tooltip({permanent:false, direction:"top"})
            .setLatLng([avgY, avgX])
            .setContent(`<strong>${r.name}</strong>`);
          layer.on("click", () => {
            tooltip.openOn(map);
            map.panTo([avgY, avgX]);
          });
          roadRefs[i] = { layer, tooltip };
        });
      }

      refreshList();
      drawSavedRoads();

      function findPathSafe(startKey,endKey,maxSteps=5000){
        const queue=[startKey],visited=new Set([startKey]),parent={};
        let steps=0;
        while(queue.length && steps<maxSteps){
          const cur=queue.shift();steps++;
          if(cur===endKey)break;
          for(const idx of (nodeMap[cur]||[])){
            const f=clone.features[idx],c=f.geometry.coordinates,ends=[c[0],c[c.length-1]];
            for(const [x,y] of ends){
              const k=key(x,y);
              if(!visited.has(k)){visited.add(k);parent[k]=cur;queue.push(k);}
            }
          }
        }
        if(steps>=maxSteps){console.warn("Search exceeded limit.");return [];}
        const path=[];let k=endKey;
        while(k){path.unshift(k);k=parent[k];}
        if(path[0]!==startKey)return[];
        const segs=[];
        for(let i=0;i<path.length-1;i++){
          const a=path[i],b=path[i+1];
          const sa=nodeMap[a]||[],sb=nodeMap[b]||[];
          segs.push(...sa.filter(x=>sb.includes(x)));
        }
        return [...new Set(segs)];
      }

      function markPoint(latlng,label){
        const m=L.marker(latlng,{icon:L.divIcon({className:"marker-label",html:label})}).addTo(map);
        markers.push(m);
      }

      // --- NEW: click directly on red roads to select nearest intersection ---
      roadsLayer.eachLayer(layer => {
        layer.on("click", e => {
          const coords = e.target.feature.geometry.coordinates;
          // Snap to nearest end of clicked road segment
          const [x1, y1] = coords[0];
          const [x2, y2] = coords[coords.length - 1];

          const distToStart = Math.hypot(e.latlng.lng - x1, e.latlng.lat - y1);
          const distToEnd = Math.hypot(e.latlng.lng - x2, e.latlng.lat - y2);
          const chosen = distToStart < distToEnd ? [x1, y1] : [x2, y2];

          const chosenKey = key(chosen[0], chosen[1]);
          const chosenLatLng = L.latLng(chosen[1], chosen[0]);

          if(!pointA){
            pointA = chosenKey;
            markPoint(chosenLatLng,"A");
            status.innerText="Select point B";
          } else {
            pointB = chosenKey;
            markPoint(chosenLatLng,"B");

            setTimeout(()=>{
              const segs = findPathSafe(pointA, pointB);
              if(segs.length){
                const feats = segs.map(i=>clone.features[i]);
                if(highlight) map.removeLayer(highlight);
                highlight = L.geoJSON(feats,{style:{color:"yellow",weight:4}}).addTo(map);
                status.innerText = "Enter name then Save";
                currentSegs = segs;
              } else {
                status.innerText = "No connection found or search limited.";
                currentSegs = null;
              }
              pointA = null; pointB = null;
              markers.forEach(m=>map.removeLayer(m)); markers=[];
            },10);
          }
        });
      });

      document.getElementById("saveBtn").onclick=()=>{
        const name=nameBox.value.trim();
        if(!name||!currentSegs){status.innerText="Select A→B and enter name.";return;}
        saved.push({name,segs:currentSegs});
        localStorage.setItem("roadNames",JSON.stringify(saved));
        refreshList();
        drawSavedRoads();
        nameBox.value="";
        currentSegs=null;
        status.innerText="Saved locally! Click new A→B";
        if(highlight){map.removeLayer(highlight);highlight=null;}
      };

      document.getElementById("clearBtn").onclick=()=>{
        if(highlight){map.removeLayer(highlight);highlight=null;}
        markers.forEach(m=>map.removeLayer(m));markers=[];
        pointA=null; pointB=null; currentSegs=null;
        status.innerText="Selection cleared. Click two roads (A→B)";
      };

      document.getElementById("downloadBtn").onclick=()=>{
        const blob=new Blob([JSON.stringify(saved,null,2)],{type:"application/json"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url;a.download="roadnames.json";a.click();
        URL.revokeObjectURL(url);
      };

      document.getElementById("importBtn").onclick = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = e => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = evt => {
            try {
              const imported = JSON.parse(evt.target.result);
              if (!Array.isArray(imported)) {
                alert("Invalid file format. Expected an array of saved roads.");
                return;
              }
              if (confirm(`Import ${imported.length} roads? (OK = Replace, Cancel = Merge)`)) {
                localStorage.setItem("roadNames", JSON.stringify(imported));
                saved.length = 0;
                imported.forEach(r => saved.push(r));
              } else {
                const existingNames = new Set(saved.map(r => r.name));
                imported.forEach(r => {
                  if (!existingNames.has(r.name)) saved.push(r);
                });
                localStorage.setItem("roadNames", JSON.stringify(saved));
              }
              refreshList();
              drawSavedRoads();
              status.innerText = "✅ Imported road data successfully!";
            } catch (err) {
              console.error(err);
              alert("Failed to parse JSON. Check console for details.");
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };
    })
    .catch(err=>console.error(err));
  </script>
</body>
</html>